
# Домашнее задание к занятию «Микросервисы: масштабирование»

### Грибанов Антон. FOPS-31

Вы работаете в крупной компании, которая строит систему на основе микросервисной архитектуры.
Вам как DevOps-специалисту необходимо выдвинуть предложение по организации инфраструктуры для разработки и эксплуатации.

## Задача 1: Кластеризация

Предложите решение для обеспечения развёртывания, запуска и управления приложениями.
Решение может состоять из одного или нескольких программных продуктов и должно описывать способы и принципы их взаимодействия.

Решение должно соответствовать следующим требованиям:
- поддержка контейнеров;
- обеспечивать обнаружение сервисов и маршрутизацию запросов;
- обеспечивать возможность горизонтального масштабирования;
- обеспечивать возможность автоматического масштабирования;
- обеспечивать явное разделение ресурсов, доступных извне и внутри системы;
- обеспечивать возможность конфигурировать приложения с помощью переменных среды, в том числе с возможностью безопасного хранения чувствительных данных таких как пароли, ключи доступа, ключи шифрования и т. п.

Обоснуйте свой выбор.

### Решение:

Используем Kubernetes как "мозг" системы, который управляет всеми контейнерами и автоматизирует рутину.

---

### Что используем и зачем:

1.  **Kubernetes (K8s)** — главная платформа:
    *   **Контейнеры:** Запускает и управляет вашими микросервисами в контейнерах.
    *   **Масштабирование:** Легко увеличить или уменьшить количество копий сервиса одной командой.
    *   **Обнаружение сервисов:** Автоматически даёт сервисам внутренние имена (как DNS), чтобы они могли находить друг друга.

2.  **Ingress NGINX** — "входная дверь" в кластер:
    *   Принимает весь внешний трафик (запросы пользователей) и грамотно распределяет его по внутренним сервисам.
    *   **Разделение доступа:** Внешний мир общается только с этой "дверью", а не с сервисами напрямую. Внутренние сервисы закрыты извне.

3.  **Autoscaler** — автомасштабирование:
    *   **Horizontal Pod Autoscaler:** Следит за нагрузкой (например, загрузкой процессора) и сам добавляет или убирает копии вашего приложения.
    *   **Cluster Autoscaler:** Если в кластере не хватает места для новых копий, автоматически добавляет новые серверы (ноды).

4.  **HashiCorp Vault** — сейф для секретов:
    *   Безопасно хранит пароли, ключи и токены.
    *   Автоматически и безопасно передаёт их приложениям при запуске. Намного безопаснее, чем просто хранить их в файлах.

---

### Как это работает вместе:

1.  Разработчик заливает код в Git. CI/CD система собирает контейнер и отправляет его в Kubernetes.
2.  K8s запускает контейнер. Vault незаметно "подкладывает" в него все необходимые пароли и ключи.
3.  Сервис регистрируется в сети K8s, и другие микросервисы начинают видеть его по имени.
4.  Пользователь делает запрос на ваш адрес (например, `api.mycompany.com`). Запрос попадает на Ingress, который перенаправляет его нужному внутреннему сервису.
5.  При росте нагрузки Autoscaler сам добавляет новые копии сервиса, чтобы всё работало быстро.

**Итог:** Это стандартное, мощное и автоматизированное решение, которое закрывает все ваши требования и является фактическим стандартом в индустрии.

## Задача 2: Распределённый кеш * (необязательная)

Разработчикам вашей компании понадобился распределённый кеш для организации хранения временной информации по сессиям пользователей.
Вам необходимо построить Redis Cluster, состоящий из трёх шард с тремя репликами.

### Схема:

![11-04-01](https://user-images.githubusercontent.com/1122523/114282923-9b16f900-9a4f-11eb-80aa-61ed09725760.png)

---

Конечно! Вот краткое и простое объяснение.

### Простое решение для Redis Cluster

**Задача:** Развернуть отказоустойчивый Redis из 3 главных узлов и 3 резервных копий.

---

### Как вариант, всё сделать на виртуальных машинах

**Распределение:**
- **VM1:** Главный узел 1 + Резервная копия от узла 3
- **VM2:** Главный узел 2 + Резервная копия от узла 1  
- **VM3:** Главный узел 3 + Резервная копия от узла 2

**Что делать:**
1. Ставим Redis на 3 виртуальные машины
2. Настраиваем в конфиге `cluster-enabled yes`
3. Выполняем одну команду для создания кластера:

   ```bash
   redis-cli --cluster create VM1:6379 VM2:6379 VM3:6379 VM1:6380 VM2:6380 VM3:6380 --cluster-replicas 1
   ```

Данные автоматически распределяются между 3 главными узлами. Если один упадет, его резервная копия сразу станет главной.


### Как оформить ДЗ?

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
